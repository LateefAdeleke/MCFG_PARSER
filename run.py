{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "1eb48e9a-04a2-43a0-8418-3735eaa8eb26",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pyparsing\n",
    "\n",
    "from typing import TypeVar, Optional\n",
    "from collections.abc import Hashable, Callable\n",
    "\n",
    "DataType = Hashable\n",
    "TreeList = list[str, Optional[list['TreeList']]]\n",
    "TreeTuple = tuple[DataType, Optional[tuple['TreeTuple', ...]]]\n",
    "\n",
    "class Tree:\n",
    "\n",
    "    LPAR = pyparsing.Suppress('(')\n",
    "    RPAR = pyparsing.Suppress(')')\n",
    "    DATA = pyparsing.Regex(r'[^\\(\\)\\s]+')\n",
    "\n",
    "    PARSER = pyparsing.Forward()\n",
    "    SUBTREE = pyparsing.ZeroOrMore(PARSER)\n",
    "    PARSERLIST = pyparsing.Group(LPAR + DATA + SUBTREE + RPAR)\n",
    "    PARSER <<= DATA | PARSERLIST\n",
    "    \n",
    "    def __init__(self, data: DataType, children: list['Tree'] = []):\n",
    "        self._data = data\n",
    "        self._children = children\n",
    "        \n",
    "        self._validate()\n",
    "  \n",
    "    def to_tuple(self) -> TreeTuple:\n",
    "        return self._data, tuple(c.to_tuple() for c in self._children)\n",
    "\n",
    "    def __hash__(self) -> int:\n",
    "        return hash(self.to_tuple())\n",
    "    \n",
    "    def __eq__(self, other: 'Tree') -> bool:\n",
    "        return self.to_tuple() == other.to_tuple()\n",
    "\n",
    "    def __str__(self) -> str:\n",
    "        return ' '.join(self.terminals)\n",
    "        \n",
    "    def __repr__(self) -> str:\n",
    "        return self.to_string()\n",
    "     \n",
    "    def to_string(self, depth=0) -> str:\n",
    "        s = (depth - 1) * '  ' +\\\n",
    "            int(depth > 0) * '--' +\\\n",
    "            self._data + '\\n'\n",
    "        s += ''.join(c.to_string(depth+1)\n",
    "                     for c in self._children)\n",
    "        \n",
    "        return s\n",
    "    \n",
    "    def __contains__(self, data: DataType) -> bool:\n",
    "        # pre-order depth-first search\n",
    "        if self._data == data:\n",
    "            return True\n",
    "        else:\n",
    "            for child in self._children:\n",
    "                if data in child:\n",
    "                    return True\n",
    "                \n",
    "            return False\n",
    "        \n",
    "    def __getitem__(self, idx: int | tuple[int, ...]) -> 'Tree':\n",
    "        if isinstance(idx, int):\n",
    "            return self._children[idx]\n",
    "        elif len(idx) == 1:\n",
    "            return self._children[idx[0]]\n",
    "        elif idx:\n",
    "            return self._children[idx[0]].__getitem__(idx[1:])\n",
    "        else:\n",
    "            return self\n",
    "        \n",
    "    @property\n",
    "    def data(self) -> DataType:\n",
    "        return self._data \n",
    "    \n",
    "    @property\n",
    "    def children(self) -> list['Tree']:\n",
    "        return self._children\n",
    "     \n",
    "    @property\n",
    "    def terminals(self) -> list[str]:\n",
    "        if self._children:\n",
    "            return [w for c in self._children \n",
    "                    for w in c.terminals]\n",
    "        else:\n",
    "            return [str(self._data)]\n",
    "        \n",
    "    def _validate(self) -> None:\n",
    "        try:\n",
    "            assert all(isinstance(c, Tree)\n",
    "                       for c in self._children)\n",
    "        except AssertionError:\n",
    "            msg = 'all children must be trees'\n",
    "            raise TypeError(msg)\n",
    "            \n",
    "    def index(self, data: DataType, index_path: tuple[int, ...] = tuple()) -> list[tuple[int, ...]]:\n",
    "        indices = [index_path] if self._data==data else []\n",
    "        root_path = [] if index_path == -1 else index_path\n",
    "        \n",
    "        indices += [j \n",
    "                    for i, c in enumerate(self._children) \n",
    "                    for j in c.index(data, root_path+(i,))]\n",
    "\n",
    "        return indices\n",
    "    \n",
    "    def relabel(self, label_map: Callable[[DataType], DataType], \n",
    "                nonterminals_only: bool = False, terminals_only: bool = False) -> 'Tree':\n",
    "        if not nonterminals_only and not terminals_only:\n",
    "            data = label_map(self._data)\n",
    "        elif nonterminals_only and self._children:\n",
    "            data = label_map(self._data)\n",
    "        elif terminals_only and not self._children:\n",
    "            data = label_map(self._data)\n",
    "        else:\n",
    "            data = self._data\n",
    "        \n",
    "        children = [c.relabel(label_map, nonterminals_only, terminals_only) \n",
    "                    for c in self._children]\n",
    "        \n",
    "        return self.__class__(data, children)\n",
    "    \n",
    "    @classmethod\n",
    "    def from_string(cls, treestr: str) -> 'Tree':\n",
    "        treelist = cls.PARSER.parseString(treestr[2:-2])[0]\n",
    "        \n",
    "        return cls.from_list(treelist)\n",
    "    \n",
    "    @classmethod\n",
    "    def from_list(cls, treelist: TreeList) -> 'Tree':\n",
    "        if isinstance(treelist, str):\n",
    "            return cls(treelist[0])\n",
    "        elif isinstance(treelist[1], str):\n",
    "            return cls(treelist[0], [cls(treelist[1])])\n",
    "        else:\n",
    "            return cls(treelist[0], [cls.from_list(l) for l in treelist[1:]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "e35b5560-5c14-4107-a353-25b6f4933ed0",
   "metadata": {},
   "outputs": [],
   "source": [
    "import re\n",
    "\n",
    "StringVariables = tuple[int, ...]\n",
    "\n",
    "class MCFGRuleElement:\n",
    "\n",
    "    \"\"\"A multiple context free grammar rule element\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    variable\n",
    "    string_variables\n",
    "\n",
    "    Attributes\n",
    "    ----------\n",
    "    symbol\n",
    "    string_variables\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, variable: str, *string_variables: StringVariables):\n",
    "        self._variable = variable\n",
    "        self._string_variables = string_variables\n",
    "\n",
    "    def __str__(self) -> str:\n",
    "        strvars = ', '.join(\n",
    "            ''.join(str(v) for v in vtup)\n",
    "            for vtup in self._string_variables\n",
    "        )\n",
    "        \n",
    "        return f\"{self._variable}({strvars})\"\n",
    "\n",
    "    def __eq__(self, other) -> bool:\n",
    "        vareq = self._variable == other._variable\n",
    "        strvareq = self._string_variables == other._string_variables\n",
    "        \n",
    "        return vareq and strvareq\n",
    "        \n",
    "    def to_tuple(self) -> tuple[str, tuple[StringVariables, ...]]:\n",
    "        return (self._variable, self._string_variables)\n",
    "\n",
    "    def __hash__(self) -> int:\n",
    "        return hash(self.to_tuple())\n",
    "        \n",
    "    @property\n",
    "    def variable(self) -> str:\n",
    "        return self._variable\n",
    "\n",
    "    @property\n",
    "    def string_variables(self) -> tuple[StringVariables, ...]:\n",
    "        return self._string_variables\n",
    "\n",
    "    @property    \n",
    "    def unique_string_variables(self) -> set[int]:\n",
    "        return {\n",
    "            i\n",
    "            for tup in self.string_variables\n",
    "            for i in tup\n",
    "        }"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "c19b365a-830a-4ded-89d8-344b23c15c3c",
   "metadata": {},
   "outputs": [],
   "source": [
    "import re\n",
    "\n",
    "StringVariables = tuple[int, ...]\n",
    "\n",
    "class MCFGRuleElement:\n",
    "\n",
    "    \"\"\"A multiple context free grammar rule element\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    variable\n",
    "    string_variables\n",
    "\n",
    "    Attributes\n",
    "    ----------\n",
    "    symbol\n",
    "    string_variables\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, variable: str, *string_variables: StringVariables):\n",
    "        self._variable = variable\n",
    "        self._string_variables = string_variables\n",
    "\n",
    "    def __str__(self) -> str:\n",
    "        strvars = ', '.join(\n",
    "            ''.join(str(v) for v in vtup)\n",
    "            for vtup in self._string_variables\n",
    "        )\n",
    "        \n",
    "        return f\"{self._variable}({strvars})\"\n",
    "\n",
    "    def __eq__(self, other) -> bool:\n",
    "        vareq = self._variable == other._variable\n",
    "        strvareq = self._string_variables == other._string_variables\n",
    "        \n",
    "        return vareq and strvareq\n",
    "        \n",
    "    def to_tuple(self) -> tuple[str, tuple[StringVariables, ...]]:\n",
    "        return (self._variable, self._string_variables)\n",
    "\n",
    "    def __hash__(self) -> int:\n",
    "        return hash(self.to_tuple())\n",
    "        \n",
    "    @property\n",
    "    def variable(self) -> str:\n",
    "        return self._variable\n",
    "\n",
    "    @property\n",
    "    def string_variables(self) -> tuple[StringVariables, ...]:\n",
    "        return self._string_variables\n",
    "\n",
    "    @property    \n",
    "    def unique_string_variables(self) -> set[int]:\n",
    "        return {\n",
    "            i\n",
    "            for tup in self.string_variables\n",
    "            for i in tup\n",
    "        }"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "2729a857-380e-4160-b059-171f102bf36f",
   "metadata": {},
   "outputs": [],
   "source": [
    "SpanIndices = tuple[int, ...]\n",
    "\n",
    "class MCFGRuleElementInstance:\n",
    "    \"\"\"An instantiated multiple context free grammar rule element\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    symbol\n",
    "    string_spans\n",
    "\n",
    "    Attributes\n",
    "    ----------\n",
    "    symbol\n",
    "    string_spans\n",
    "    \"\"\"\n",
    "    def __init__(self, variable: str, *string_spans: SpanIndices):\n",
    "        self._variable = variable\n",
    "        self._string_spans = string_spans\n",
    "\n",
    "    def __eq__(self, other: 'MCFGRuleElementInstance') -> bool:\n",
    "        vareq = self._variable == other._variable\n",
    "        strspaneq = self._string_spans == other._string_spans\n",
    "        \n",
    "        return vareq and strspaneq\n",
    "        \n",
    "    def to_tuple(self) -> tuple[str, tuple[SpanIndices, ...]]:\n",
    "        return (self._variable, self._string_spans)\n",
    "\n",
    "    def __hash__(self) -> int:\n",
    "        return hash(self.to_tuple())\n",
    "\n",
    "    def __str__(self):\n",
    "        strspans = ', '.join(\n",
    "            str(list(stup))\n",
    "            for stup in self._string_spans\n",
    "        )\n",
    "        \n",
    "        return f\"{self._variable}({strspans})\"\n",
    "\n",
    "    def __repr__(self) -> str:\n",
    "        return self.__str__()\n",
    "    \n",
    "    @property\n",
    "    def variable(self) -> str:\n",
    "        return self._variable\n",
    "\n",
    "    @property\n",
    "    def string_spans(self) -> tuple[SpanIndices, ...]:\n",
    "        return self._string_spans"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "37cf7c17-bfd4-457d-bf94-f88e1ae28d28",
   "metadata": {},
   "outputs": [],
   "source": [
    "SpanMap = dict[int, SpanIndices]\n",
    "\n",
    "class MCFGRule:\n",
    "    \"\"\"A linear multiple context free grammar rule\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    left_side \n",
    "    right_side\n",
    "\n",
    "    Attributes\n",
    "    ----------\n",
    "    left_side\n",
    "    right_side\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, left_side: MCFGRuleElement, *right_side: MCFGRuleElement):\n",
    "        self._left_side = left_side\n",
    "        self._right_side = right_side\n",
    "\n",
    "        self._validate()\n",
    "\n",
    "    def to_tuple(self) -> tuple[MCFGRuleElement, tuple[MCFGRuleElement, ...]]:\n",
    "        return (self._left_side, self._right_side)\n",
    "\n",
    "    def __hash__(self) -> int:\n",
    "        return hash(self.to_tuple())\n",
    "    \n",
    "    def __repr__(self) -> str:\n",
    "        return '<Rule: '+str(self)+'>'\n",
    "        \n",
    "    def __str__(self) -> str:\n",
    "        if self.is_epsilon:\n",
    "            return str(self._left_side)                \n",
    "\n",
    "        else:\n",
    "            return str(self._left_side) +\\\n",
    "                ' -> ' +\\\n",
    "                ' '.join(str(el) for el in self._right_side)\n",
    "\n",
    "    def __eq__(self, other: 'MCFGRule') -> bool:\n",
    "        left_side_equal = self._left_side == other._left_side\n",
    "        right_side_equal = self._right_side == other._right_side\n",
    "\n",
    "        return left_side_equal and right_side_equal\n",
    "\n",
    "    def _validate(self):\n",
    "        vs = [\n",
    "            el.unique_string_variables\n",
    "            for el in self.right_side\n",
    "        ]\n",
    "        sharing = any(\n",
    "            vs1.intersection(vs2)\n",
    "            for i, vs1 in enumerate(vs)\n",
    "            for j, vs2 in enumerate(vs)\n",
    "            if i < j\n",
    "        )\n",
    "\n",
    "        if sharing:\n",
    "            raise ValueError(\n",
    "                'right side variables cannot share '\n",
    "                'string variables'\n",
    "            )\n",
    "\n",
    "        if not self.is_epsilon:\n",
    "            left_vars = self.left_side.unique_string_variables\n",
    "            right_vars = {\n",
    "                var for el in self.right_side\n",
    "                for var in el.unique_string_variables\n",
    "            }\n",
    "            if left_vars != right_vars:\n",
    "                raise ValueError(\n",
    "                    'number of arguments to instantiate must '\n",
    "                    'be equal to number of unique string_variables'\n",
    "                )\n",
    "        \n",
    "    @property\n",
    "    def left_side(self) -> MCFGRuleElement:\n",
    "        return self._left_side\n",
    "\n",
    "    @property\n",
    "    def right_side(self) -> tuple[MCFGRuleElement, ...]:\n",
    "        return self._right_side\n",
    "\n",
    "    @property\n",
    "    def is_epsilon(self) -> bool:\n",
    "        return len(self._right_side) == 0\n",
    "\n",
    "    @property\n",
    "    def unique_variables(self) -> set[str]:\n",
    "        return {\n",
    "            el.variable\n",
    "            for el in [self._left_side]+list(self._right_side)\n",
    "        }\n",
    "\n",
    "    def instantiate_left_side(self, *right_side: MCFGRuleElementInstance) -> MCFGRuleElementInstance:\n",
    "        \"\"\"Instantiate the left side of the rule given an instantiated right side\n",
    "\n",
    "        Parameters\n",
    "        ----------\n",
    "        right_side\n",
    "            The instantiated right side of the rule.\n",
    "        \"\"\"\n",
    "        \n",
    "        if self.is_epsilon:\n",
    "            strvars = tuple(v[0] for v in self._left_side.string_variables)\n",
    "            strconst = tuple(el.variable for el in right_side)\n",
    "            \n",
    "            if strconst == strvars:\n",
    "                return MCFGRuleElementInstance(\n",
    "                    self._left_side.variable,\n",
    "                    *[s for el in right_side for s in el.string_spans]\n",
    "                )\n",
    "\n",
    "        new_spans = []\n",
    "        span_map = self._build_span_map(right_side)\n",
    "        \n",
    "        for vs in self._left_side.string_variables:\n",
    "            for i in range(1,len(vs)):\n",
    "                end_prev = span_map[vs[i-1]][1]\n",
    "                begin_curr = span_map[vs[i]][0]\n",
    "\n",
    "                if end_prev != begin_curr:\n",
    "                    raise ValueError(\n",
    "                        f\"Spans {span_map[vs[i-1]]} and {span_map[vs[i]]} \"\n",
    "                        f\"must be adjacent according to {self} but they \"\n",
    "                        \"are not.\"\n",
    "                    )\n",
    "                \n",
    "            begin_span = span_map[vs[0]][0]\n",
    "            end_span = span_map[vs[-1]][1]\n",
    "\n",
    "            new_spans.append((begin_span, end_span))\n",
    "\n",
    "        return MCFGRuleElementInstance(\n",
    "            self._left_side.variable, *new_spans\n",
    "        )\n",
    "\n",
    "    \n",
    "    def _build_span_map(self, right_side: tuple[MCFGRuleElementInstance, ...]) -> SpanMap:\n",
    "        \"\"\"Construct a mapping from string variables to string spans\"\"\"\n",
    "        \n",
    "        if self._right_side_aligns(right_side):\n",
    "            return {\n",
    "                strvar[0]: strspan\n",
    "                for elem, eleminst in zip(\n",
    "                    self._right_side,\n",
    "                    right_side\n",
    "                )\n",
    "                for strvar, strspan in zip(\n",
    "                    elem.string_variables,\n",
    "                    eleminst.string_spans\n",
    "                )\n",
    "            }\n",
    "        else:\n",
    "            raise ValueError(\n",
    "                f\"Instantiated right side {right_side} do not \"\n",
    "                f\"align with rule's right side {self._right_side}\"\n",
    "            )\n",
    "\n",
    "    def _right_side_aligns(self, right_side: tuple[MCFGRuleElementInstance, ...]) -> bool:\n",
    "        \"\"\"Check whether the right side aligns\"\"\"\n",
    "\n",
    "        if len(right_side) == len(self._right_side):\n",
    "            vars_match = all(\n",
    "                elem.variable == eleminst.variable\n",
    "                for elem, eleminst in zip(self._right_side, right_side)\n",
    "            )\n",
    "            strvars_match = all(\n",
    "                len(elem.string_variables) == len(eleminst.string_spans)\n",
    "                for elem, eleminst in zip(self._right_side, right_side)\n",
    "            )\n",
    "\n",
    "            return vars_match and strvars_match\n",
    "        else:\n",
    "            return False \n",
    "\n",
    "    @classmethod\n",
    "    def from_string(cls, rule_string) -> 'MCFGRule':\n",
    "        elem_strs = re.findall('(\\w+)\\(((?:\\w+,? ?)+?)\\)', rule_string)\n",
    "\n",
    "        elem_tuples = [(var, [v.strip()\n",
    "                              for v in svs.split(',')])\n",
    "                       for var, svs in elem_strs]\n",
    "\n",
    "        if len(elem_tuples) == 1:\n",
    "            return cls(MCFGRuleElement(elem_tuples[0][0],\n",
    "                                   tuple(w for w in elem_tuples[0][1])))\n",
    "\n",
    "        else:\n",
    "            strvars = [v for _, sv in elem_tuples[1:] for v in sv]\n",
    "\n",
    "            # no duplicate string variables\n",
    "            try:\n",
    "                assert len(strvars) == len(set(strvars))\n",
    "            except AssertionError:\n",
    "                msg = 'variables duplicated on right side of '+rule_string\n",
    "                raise ValueError(msg)\n",
    "\n",
    "            \n",
    "            elem_left = MCFGRuleElement(elem_tuples[0][0],\n",
    "                                    *[tuple([strvars.index(v)\n",
    "                                             for v in re.findall('('+'|'.join(strvars)+')', vs)])\n",
    "                                      for vs in elem_tuples[0][1]])\n",
    "\n",
    "            elems_right = [MCFGRuleElement(var, *[(strvars.index(sv),)\n",
    "                                              for sv in svs])\n",
    "                           for var, svs in elem_tuples[1:]]\n",
    "\n",
    "            return cls(elem_left, *elems_right)\n",
    "        \n",
    "    def string_yield(self):\n",
    "        if self.is_epsilon:\n",
    "            return self._left_side.variable\n",
    "        else:\n",
    "            raise ValueError(\n",
    "                'string_yield is only implemented for epsilon rules'\n",
    "            )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 68,
   "id": "4484ccc6-2d22-4777-a227-43aebdb967be",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<Rule: S(02, 13) -> NP(0, 1) VP(2, 3)>"
      ]
     },
     "execution_count": 68,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "rule = MCFGRule.from_string('S(w1u, x1v) -> NP(w1, x1) VP(u, v)')\n",
    "\n",
    "rule\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "id": "9fe5afaa-122c-4aa5-b18e-728239e04cdf",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "S([1, 4], [5, 8])"
      ]
     },
     "execution_count": 69,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "rule.instantiate_left_side(\n",
    "    MCFGRuleElementInstance(\"NP\", (1, 2), (5, 7)),\n",
    "    MCFGRuleElementInstance(\"VP\", (2, 4), (7, 8))\n",
    ")\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 74,
   "id": "1eaba8b2-87b9-462e-819b-ab4e282bb7d2",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "S([0, 4], [5, 8])\n"
     ]
    }
   ],
   "source": [
    "\"\"\"the system can infer the left side of a rule from the combination of its right sides\n",
    "    the discontinuity in the components of the first variable means that an element of the second syllable\n",
    "    starts at the right integer of the first part of the firs variable and ends at the start of the second \n",
    "    component of the first first variable\"\"\"\n",
    "\n",
    "try:\n",
    "    instance = rule.instantiate_left_side(\n",
    "        MCFGRuleElementInstance(\"NP\", (0, 1), (5,7)),\n",
    "        MCFGRuleElementInstance(\"VP\", (1, 4), (7,8))\n",
    "    )\n",
    "    print(instance)\n",
    "except ValueError as e:\n",
    "    print(f\"Error: {e}\")\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 75,
   "id": "dcdaec1c-9979-4bf4-93ff-74c81bd891b4",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<Rule: Src(2, 031) -> NPdisloc(0, 1) VPrc(2, 3)>"
      ]
     },
     "execution_count": 75,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "rule1 = MCFGRule.from_string ('Src(w, uxv) -> NPdisloc(u, v) VPrc(w, x)')\n",
    "\n",
    "rule1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "id": "a31f8e05-3ad1-430b-86bc-af7c4d86afcc",
   "metadata": {},
   "outputs": [
    {
     "ename": "ValueError",
     "evalue": "Instantiated right side (NPdisloc([0, 1]), VPrc([2], [0, 3])) do not align with rule's right side (<__main__.MCFGRuleElement object at 0x112c8b390>, <__main__.MCFGRuleElement object at 0x112c8af50>)",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "Cell \u001b[0;32mIn[82], line 1\u001b[0m\n\u001b[0;32m----> 1\u001b[0m instance \u001b[38;5;241m=\u001b[39m rule\u001b[38;5;241m.\u001b[39minstantiate_left_side(MCFGRuleElementInstance(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mNPdisloc\u001b[39m\u001b[38;5;124m\"\u001b[39m, (\u001b[38;5;241m0\u001b[39m, \u001b[38;5;241m1\u001b[39m)), \n\u001b[1;32m      2\u001b[0m                                        MCFGRuleElementInstance(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mVPrc\u001b[39m\u001b[38;5;124m\"\u001b[39m,(\u001b[38;5;241m2\u001b[39m,), (\u001b[38;5;241m0\u001b[39m,\u001b[38;5;241m3\u001b[39m)))\n",
      "Cell \u001b[0;32mIn[27], line 116\u001b[0m, in \u001b[0;36mMCFGRule.instantiate_left_side\u001b[0;34m(self, *right_side)\u001b[0m\n\u001b[1;32m    110\u001b[0m         \u001b[38;5;28;01mreturn\u001b[39;00m MCFGRuleElementInstance(\n\u001b[1;32m    111\u001b[0m             \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_left_side\u001b[38;5;241m.\u001b[39mvariable,\n\u001b[1;32m    112\u001b[0m             \u001b[38;5;241m*\u001b[39m[s \u001b[38;5;28;01mfor\u001b[39;00m el \u001b[38;5;129;01min\u001b[39;00m right_side \u001b[38;5;28;01mfor\u001b[39;00m s \u001b[38;5;129;01min\u001b[39;00m el\u001b[38;5;241m.\u001b[39mstring_spans]\n\u001b[1;32m    113\u001b[0m         )\n\u001b[1;32m    115\u001b[0m new_spans \u001b[38;5;241m=\u001b[39m []\n\u001b[0;32m--> 116\u001b[0m span_map \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_build_span_map(right_side)\n\u001b[1;32m    118\u001b[0m \u001b[38;5;28;01mfor\u001b[39;00m vs \u001b[38;5;129;01min\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_left_side\u001b[38;5;241m.\u001b[39mstring_variables:\n\u001b[1;32m    119\u001b[0m     \u001b[38;5;28;01mfor\u001b[39;00m i \u001b[38;5;129;01min\u001b[39;00m \u001b[38;5;28mrange\u001b[39m(\u001b[38;5;241m1\u001b[39m,\u001b[38;5;28mlen\u001b[39m(vs)):\n",
      "Cell \u001b[0;32mIn[27], line 156\u001b[0m, in \u001b[0;36mMCFGRule._build_span_map\u001b[0;34m(self, right_side)\u001b[0m\n\u001b[1;32m    144\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m {\n\u001b[1;32m    145\u001b[0m         strvar[\u001b[38;5;241m0\u001b[39m]: strspan\n\u001b[1;32m    146\u001b[0m         \u001b[38;5;28;01mfor\u001b[39;00m elem, eleminst \u001b[38;5;129;01min\u001b[39;00m \u001b[38;5;28mzip\u001b[39m(\n\u001b[0;32m   (...)\u001b[0m\n\u001b[1;32m    153\u001b[0m         )\n\u001b[1;32m    154\u001b[0m     }\n\u001b[1;32m    155\u001b[0m \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[0;32m--> 156\u001b[0m     \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mValueError\u001b[39;00m(\n\u001b[1;32m    157\u001b[0m         \u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mInstantiated right side \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mright_side\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m do not \u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m    158\u001b[0m         \u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124malign with rule\u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124ms right side \u001b[39m\u001b[38;5;132;01m{\u001b[39;00m\u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_right_side\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m    159\u001b[0m     )\n",
      "\u001b[0;31mValueError\u001b[0m: Instantiated right side (NPdisloc([0, 1]), VPrc([2], [0, 3])) do not align with rule's right side (<__main__.MCFGRuleElement object at 0x112c8b390>, <__main__.MCFGRuleElement object at 0x112c8af50>)"
     ]
    }
   ],
   "source": [
    "\n",
    "instance = rule.instantiate_left_side(MCFGRuleElementInstance(\"NPdisloc\", (0, 1), (), \n",
    "                                       MCFGRuleElementInstance(\"VPrc\",(2,), (0,3)))\n",
    "                                                              \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 89,
   "id": "997f244c-53c1-4675-abe0-2e2f89a6b104",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<function __main__.test_mcfg_rule_element_str()>"
      ]
     },
     "execution_count": 89,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#import pytest\n",
    "#|from grammar import MCFGRuleElement\n",
    "\n",
    "def test_mcfg_rule_element_str():\n",
    "    element = MCFGRuleElement('NP', (0,), (1,))\n",
    "    assert str(element) == \"NP(0, 1)\", \"String representation should match\"\n",
    "\n",
    "def test_mcfg_rule_element_equality():\n",
    "    element1 = MCFGRuleElement('VP', (0, 1))\n",
    "    element2 = MCFGRuleElement('VP', (0, 1))\n",
    "    assert element1 == element2, \"Elements with same configuration should be equal\"\n",
    "\n",
    "test_mcfg_rule_element_str\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 84,
   "id": "4f8b8db3-3e8f-4de4-b5a0-51b5bfda488d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Collecting pytest\n",
      "  Downloading pytest-8.2.0-py3-none-any.whl.metadata (7.5 kB)\n",
      "Collecting iniconfig (from pytest)\n",
      "  Downloading iniconfig-2.0.0-py3-none-any.whl.metadata (2.6 kB)\n",
      "Requirement already satisfied: packaging in /Users/lateefadeleke/miniconda3/lib/python3.11/site-packages (from pytest) (23.1)\n",
      "Collecting pluggy<2.0,>=1.5 (from pytest)\n",
      "  Using cached pluggy-1.5.0-py3-none-any.whl.metadata (4.8 kB)\n",
      "Downloading pytest-8.2.0-py3-none-any.whl (339 kB)\n",
      "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m339.2/339.2 kB\u001b[0m \u001b[31m4.7 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0ma \u001b[36m0:00:01\u001b[0m\n",
      "\u001b[?25hUsing cached pluggy-1.5.0-py3-none-any.whl (20 kB)\n",
      "Downloading iniconfig-2.0.0-py3-none-any.whl (5.9 kB)\n",
      "Installing collected packages: pluggy, iniconfig, pytest\n",
      "  Attempting uninstall: pluggy\n",
      "    Found existing installation: pluggy 1.0.0\n",
      "    Uninstalling pluggy-1.0.0:\n",
      "      Successfully uninstalled pluggy-1.0.0\n",
      "Successfully installed iniconfig-2.0.0 pluggy-1.5.0 pytest-8.2.0\n"
     ]
    }
   ],
   "source": [
    "!pip install pytest"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6b7cf445-e845-4b71-b651-a7f48f7a0d29",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
